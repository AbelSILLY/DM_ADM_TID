---
title: "TP2_ADM"
author: "Arthur TENA"
date: "11/7/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Question 1 :
##Préparation des données :

```{r}
library(readr)
#villes <- read_delim("villes.csv", delim = "\t", 
#    escape_double = FALSE, trim_ws = TRUE)
#villes
data<-read.table('./villes.csv',header=TRUE,fill=TRUE)
rname<-data[,1]
rname
Villes=data[2:55]
row.names(Villes)<-rname
Villes
n=nrow(villes)
villes=scale(Villes)*sqrt(n/(n-1))
villes
dv=dist(Villes, method="euclidean") #création de la matrice des distances euclidiennes:
#print(dv)
CAHV = hclust(d=dv, method = "ward.D") # CAH avec Ward 
plot(CAHV) #Dendrogramme de la hiérarchie indicée
#Coupure de l'arbre et fabrication de la variable de classe correspondant à la partition obtenue, par exemple k=2 classes:
PV2 = cutree(tree = CAHV, k=2)
# Calcul du R2 des variables avec la variable de classe. On va stocker tous les R2 dans un seul vecteur: R2.
R2_PV2 = cbind(rep(0 , ncol(villes)))
#Puis, on calcule les R2 de toutes les variables avec la variable de classe et on met les résultats dans R2:
for (i in cbind(1:ncol(villes))) {
  R2_PV2[i] = summary(lm(villes[,i]~as.factor(PV2)))$r.squared}
#On peut réassigner les noms des variables aux éléments de ce vecteur
row.names(R2_PV2) = colnames(Villes)
R2_PV2
R2G_PV2 = mean(R2_PV2)
R2G_PV2
boxplot(villes[,9]~as.factor(PV2)) 
#Transformation d'une variable qualitative en matrice d'indicatrices
IC2Vil = data.frame(model.matrix(~as.factor(PV2)-1))
print(IC2Vil)
#Calcul matriciel des centres de gravité de classes de la CAH:
mIC2Vil = as.matrix(IC2Vil)
mVil = as.matrix(villes)
CentresC2 = solve(t(mIC2Vil) %*% mIC2Vil)  %*%  t(mIC2Vil)%*% mVil
#K-means à partir de ces centres initiaux
KMV2 = kmeans(villes, CentresC2)
#La variable de classe ainsi produite est dans
KMV2$cluster
```


## Création de Dataframe par Catégorie :

```{r}
Economie=as.data.frame(villes[,c(1:9,26:34,48:54)])
Risques=as.data.frame(villes[,10:25])
Nature=as.data.frame(villes[,35:40])
Culture=as.data.frame(villes[,41:47])

#Economie :
dve=dist(Economie, method="euclidean") #création de la matrice des distances euclidiennes
CAHV = hclust(d=dve, method = "ward.D")
plot(CAHV)
PV2 = cutree(tree = CAHV, k=3)
IC2ec = data.frame(model.matrix(~as.factor(PV2)-1))
mIC2ec = as.matrix(IC2ec)
mec = as.matrix(Economie)
CentresC2 = solve(t(mIC2ec) %*% mIC2ec)  %*%  t(mIC2ec)%*% mec
KMV2 = kmeans(Economie, CentresC2)
KMV2$cluster

#Risques :
dvr=dist(Risques, method="euclidean") #création de la matrice des distances euclidiennes
CAHV = hclust(d=dvr, method = "ward.D")
plot(CAHV)
PV2 = cutree(tree = CAHV, k=2)
IC2ris = data.frame(model.matrix(~as.factor(PV2)-1))
mIC2ris = as.matrix(IC2ris)
mris = as.matrix(Risques)
CentresC2 = solve(t(mIC2ris) %*% mIC2ris)  %*%  t(mIC2ris)%*% mris
KMV2 = kmeans(Risques, CentresC2)
KMV2$cluster

#Nature :
dvn=dist(Nature, method="euclidean") #création de la matrice des distances euclidiennes
CAHV = hclust(d=dvn, method = "ward.D")
plot(CAHV)
PV2 = cutree(tree = CAHV, k=3)
IC2nat = data.frame(model.matrix(~as.factor(PV2)-1))
mIC2nat = as.matrix(IC2nat)
mnat = as.matrix(Nature)
CentresC2 = solve(t(mIC2nat) %*% mIC2nat)  %*%  t(mIC2nat)%*% mnat
KMV2 = kmeans(Nature, CentresC2)
KMV2$cluster

#Culture :
dvc=dist(Culture, method="euclidean") #création de la matrice des distances euclidiennes
CAHV = hclust(d=dvc, method = "ward.D")
plot(CAHV)
PV2 = cutree(tree = CAHV, k=3)
IC2cul = data.frame(model.matrix(~as.factor(PV2)-1))
mIC2cul = as.matrix(IC2cul)
mcul = as.matrix(Culture)
CentresC2 = solve(t(mIC2cul) %*% mIC2cul)  %*%  t(mIC2cul)%*% mcul
KMV2 = kmeans(Culture, CentresC2)
KMV2$cluster
```







